using System.Security.Cryptography;
using System.Text;
using Microsoft.Extensions.Options;

namespace DragonSpark.AutoCert.Helpers;

/// <summary>
///     Helper for encrypting and decrypting account keys.
/// </summary>
public class AccountKeyCipher(IOptions<AutoCertOptions> options)
{
    private const int SaltSize = 32; // 256 bits
    private const int KeySize = 32; // 256 bits
    private const int Iterations = 100000;
    private readonly string _password = options.Value.CertificatePassword;

    /// <summary>
    ///     Encrypts the plain text using AES encryption with a derived key.
    /// </summary>
    /// <param name="plainText">The text to encrypt.</param>
    /// <returns>Base64 encoded cipher text.</returns>
    public string Encrypt(string plainText)
    {
        if (string.IsNullOrEmpty(plainText)) return plainText;

        // Generate a random salt
        var salt = RandomNumberGenerator.GetBytes(SaltSize);

        using var aes = CreateAes(salt);

        // Encrypt
        using var encryptor = aes.CreateEncryptor(aes.Key, aes.IV);
        using var ms = new MemoryStream();

        // Write Salt (32 bytes)
        ms.Write(salt, 0, salt.Length);

        // Write IV (16 bytes - AES default)
        ms.Write(aes.IV, 0, aes.IV.Length);

        using (var cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
        using (var sw = new StreamWriter(cs))
        {
            sw.Write(plainText);
        }

        return Convert.ToBase64String(ms.ToArray());
    }

    /// <summary>
    ///     Decrypts the cipher text.
    /// </summary>
    /// <param name="cipherText">Base64 encoded cipher text.</param>
    /// <returns>The original plain text.</returns>
    /// <exception cref="CryptographicException">Thrown when decryption fails.</exception>
    public string? Decrypt(string cipherText)
    {
        if (string.IsNullOrEmpty(cipherText)) return cipherText;

        try
        {
            var fullCipher = Convert.FromBase64String(cipherText);

            using var aes = Aes.Create();
            var ivSize = aes.IV.Length;
            var minLength = SaltSize + ivSize;

            if (fullCipher.Length < minLength)
                throw new CryptographicException("Invalid cipher data length.");

            // Extract Salt
            var salt = new byte[SaltSize];
            Array.Copy(fullCipher, 0, salt, 0, SaltSize);

            // Derive Key
            var key = Rfc2898DeriveBytes.Pbkdf2(
                Encoding.UTF8.GetBytes(_password),
                salt,
                Iterations,
                HashAlgorithmName.SHA256,
                KeySize);

            aes.Key = key;

            // Extract IV
            var iv = new byte[ivSize];
            Array.Copy(fullCipher, SaltSize, iv, 0, ivSize);
            aes.IV = iv;

            // Decrypt
            using var decryptor = aes.CreateDecryptor(aes.Key, aes.IV);
            using var ms = new MemoryStream(fullCipher, minLength, fullCipher.Length - minLength);
            using var cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read);
            using var sr = new StreamReader(cs);

            return sr.ReadToEnd();
        }
        catch (Exception)
        {
            // Strict security: If it fails, we throw. 
            // We do NOT return null or fallback to legacy to avoid downgrading attacks or usage of insecure keys.
            throw new CryptographicException(
                "Failed to decrypt account key. The key may be invalid, corrupted, or encrypted with a legacy format that is no longer supported.");
        }
    }

    private Aes CreateAes(byte[] salt)
    {
        var aes = Aes.Create();

        var key = Rfc2898DeriveBytes.Pbkdf2(
            Encoding.UTF8.GetBytes(_password),
            salt,
            Iterations,
            HashAlgorithmName.SHA256,
            KeySize);

        aes.Key = key;

        // IV is automatically generated by Aes.Create(), but we set the Key.
        return aes;
    }
}